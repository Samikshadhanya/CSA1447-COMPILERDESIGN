
# Compiler Design Laboratory

A comprehensive collection of compiler design experiments covering lexical analysis, syntax analysis, semantic analysis, and code generation. This repository contains practical implementations of compiler components using LEX, YACC, and C programming, demonstrating the complete compilation process from source code to executable.

## Project Overview

This laboratory curriculum provides hands-on experience with compiler construction techniques and tools. The experiments cover all phases of compilation including lexical analysis with LEX programs, syntax analysis with YACC, semantic analysis, intermediate code generation, optimization, and target code generation.

## Key Technologies and Tools

- **LEX (Lexical Analyzer Generator)** - Automatic generation of lexical analyzers from regular expressions
- **YACC (Yet Another Compiler Compiler)** - Parser generator for context-free grammars
- **C Programming Language** - Implementation language for compiler components
- **Regular Expressions** - Pattern matching for token recognition
- **Context-Free Grammars** - Formal grammar specification for syntax analysis
- **Symbol Table Management** - Identifier storage and scope handling
- **Intermediate Code Generation** - Three-address code and syntax-directed translation
- **Code Optimization** - Performance improvement techniques
- **Target Code Generation** - Assembly language code generation

## Laboratory Categories

### Lexical Analysis
Implementation of lexical analyzers using LEX for token recognition, handling keywords, identifiers, operators, and literals. Includes error handling and symbol table integration.

### Syntax Analysis
Parser implementation using YACC for context-free grammar processing. Covers top-down and bottom-up parsing techniques with error recovery mechanisms.

### Semantic Analysis
Type checking, scope resolution, and semantic error detection. Implementation of attribute grammars and syntax-directed translation schemes.

### Intermediate Code Generation
Three-address code generation, syntax-directed translation, and intermediate representation optimization techniques.

### Code Optimization
Implementation of various optimization techniques including constant folding, dead code elimination, and loop optimization.

### Target Code Generation
Assembly language code generation with register allocation and instruction selection algorithms.

## Learning Outcomes

This laboratory curriculum provides practical experience with:
- Lexical analyzer design and implementation using LEX
- Parser construction using YACC and hand-coded techniques
- Symbol table management and scope handling
- Semantic analysis and type checking implementation
- Intermediate code generation and optimization
- Target code generation for assembly language
- Error handling and recovery mechanisms
- Integration of compiler phases

Each experiment builds understanding of compiler construction through practical implementation, combining theoretical concepts with hands-on programming experience.

## Complete List of Experiments

### Day 1 - Introduction to Compiler Tools
1.1 Setting up LEX and YACC Development Environment
1.2 Basic LEX Program Structure and Regular Expressions
1.3 Simple Token Recognition using LEX
1.4 Character and String Processing with LEX
1.5 LEX Program for Counting Lines, Words, and Characters

### Day 2 - Basic Lexical Analysis
2.1 LEX Program to Recognize Keywords and Identifiers
2.2 LEX Program to Recognize Numbers (Integer and Float)
2.3 LEX Program to Recognize Operators and Delimiters
2.4 LEX Program to Remove Comments from C Programs
2.5 LEX Program to Count Specific Patterns in Text

### Day 3 - Advanced Lexical Analysis
3.1 LEX Program to Recognize String Literals and Escape Sequences
3.2 LEX Program for Preprocessing Directives
3.3 LEX Program to Validate Email Addresses
3.4 LEX Program to Recognize Regular Expressions
3.5 LEX Program with Error Handling and Recovery

### Day 4 - Symbol Table Implementation
4.1 Symbol Table Creation and Management
4.2 Hash Table Implementation for Symbol Storage
4.3 Scope Handling in Symbol Tables
4.4 Symbol Table Integration with LEX
4.5 Symbol Table Lookup and Insertion Operations

### Day 5 - Introduction to YACC
5.1 Basic YACC Program Structure and Grammar Rules
5.2 Simple Calculator using YACC
5.3 YACC Program for Arithmetic Expression Evaluation
5.4 YACC Program with Error Handling
5.5 Integration of LEX and YACC Programs

### Day 6 - Expression Parsing
6.1 YACC Program for Infix Expression Parsing
6.2 YACC Program for Postfix Expression Evaluation
6.3 YACC Program for Prefix Expression Handling
6.4 YACC Program for Boolean Expression Evaluation
6.5 Precedence and Associativity in YACC

### Day 7 - Control Structure Parsing
7.1 YACC Program for If-Else Statement Parsing
7.2 YACC Program for Loop Structure Recognition
7.3 YACC Program for Switch-Case Statement Parsing
7.4 YACC Program for Function Declaration Parsing
7.5 YACC Program for Block Structure Handling

### Day 8 - Advanced Grammar Processing
8.1 YACC Program for Nested Structure Parsing
8.2 YACC Program for Array Declaration and Access
8.3 YACC Program for Pointer Operations
8.4 YACC Program for Structure and Union Declarations
8.5 YACC Program for Type Declarations

### Day 9 - Semantic Analysis
9.1 Type Checking Implementation
9.2 Scope Resolution and Variable Declaration
9.3 Function Call Validation and Parameter Matching
9.4 Array Bounds Checking
9.5 Semantic Error Detection and Reporting

### Day 10 - Intermediate Code Generation
10.1 Three-Address Code Generation for Expressions
10.2 Three-Address Code for Assignment Statements
10.3 Three-Address Code for Control Structures
10.4 Three-Address Code for Function Calls
10.5 Quadruple and Triple Representation

### Day 11 - Syntax-Directed Translation
11.1 Attribute Grammar Implementation
11.2 Inherited and Synthesized Attributes
11.3 Translation Schemes for Expressions
11.4 Translation Schemes for Statements
11.5 Bottom-Up Translation Implementation

### Day 12 - Code Optimization Techniques
12.1 Constant Folding and Propagation
12.2 Dead Code Elimination
12.3 Common Subexpression Elimination
12.4 Loop Optimization Techniques
12.5 Peephole Optimization

### Day 13 - Advanced Code Generation
13.1 Basic Block Identification and Flow Graphs
13.2 Register Allocation Algorithms
13.3 Instruction Selection and Scheduling
13.4 Assembly Code Generation for Expressions
13.5 Assembly Code Generation for Control Structures

### Day 14 - Error Handling and Recovery
14.1 Lexical Error Detection and Recovery
14.2 Syntax Error Recovery in YACC
14.3 Semantic Error Handling
14.4 Error Message Generation and Reporting
14.5 Panic Mode Recovery Implementation

### Day 15 - Complete Compiler Implementation
15.1 Mini Compiler for Simple Language
15.2 Integration of All Compiler Phases
15.3 Testing and Debugging Compiler Components
15.4 Performance Analysis of Compiler
15.5 Compiler Optimization and Enhancement

### Day 16 - Advanced Compiler Topics
16.1 Recursive Descent Parser Implementation
16.2 LR Parser Construction
16.3 LALR Parser Implementation
16.4 Shift-Reduce Conflict Resolution
16.5 Parser Generator Comparison

### Day 17 - Specialized Compiler Applications
17.1 Domain-Specific Language Compiler
17.2 Interpreter Implementation
17.3 Cross-Compiler Development
17.4 Just-In-Time Compilation Techniques
17.5 Virtual Machine Code Generation

### Day 18 - Compiler Testing and Validation
18.1 Compiler Testing Strategies
18.2 Test Case Generation for Compiler
18.3 Regression Testing Implementation
18.4 Performance Benchmarking
18.5 Compiler Validation and Verification
