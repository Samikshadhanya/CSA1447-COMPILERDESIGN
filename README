# Compiler Design Laboratory – Hands-On Experiments

A practical collection of compiler construction experiments designed to explore the complete compilation process—from source code to machine-level representation. This repository contains hands-on implementations of major compiler phases including lexical analysis, syntax analysis, semantic analysis, intermediate code generation, optimization, and target code generation using **LEX**, **YACC**, and **C programming**.

## 📌 Project Overview

This laboratory curriculum offers experiential learning in compiler design, guiding students through each stage of the compilation pipeline. Using tools like LEX and YACC, students implement real-world components of a compiler such as tokenizers, parsers, symbol tables, and code generators.

## 🧠 Key Concepts and Technologies

* **LEX** – Lexical analyzer generator for token recognition based on regular expressions
* **YACC** – Parser generator for context-free grammar processing and syntax tree construction
* **C Language** – Base programming language for implementing compiler logic
* **Regular Expressions** – Token patterns for lexical recognition
* **Context-Free Grammar (CFG)** – Syntax structure for programming languages
* **Symbol Table** – Data structure for managing variables, types, and scopes
* **Intermediate Code Generation** – Syntax-directed translation and three-address code
* **Code Optimization** – Performance improvement through advanced optimization techniques
* **Target Code Generation** – Producing low-level or assembly code with proper register handling

## 📁 Laboratory Categories

### 🔹 Lexical Analysis

* Design and implementation of lexical analyzers using **LEX**
* Token identification for keywords, identifiers, literals, and operators
* Error handling and symbol table integration

### 🔹 Syntax Analysis

* Syntax tree construction using **YACC**
* Context-free grammar parsing (top-down and bottom-up techniques)
* Syntax error detection and recovery

### 🔹 Semantic Analysis

* Type checking and scope validation
* Attribute grammar implementation
* Syntax-directed translation for semantic rule enforcement

### 🔹 Intermediate Code Generation

* Generation of **Three-Address Code (TAC)**
* Implementation of syntax-directed translation schemes
* Intermediate representations for later optimization

### 🔹 Code Optimization

* Basic optimization techniques such as:

  * Constant folding
  * Dead code elimination
  * Loop optimization
* Enhancing intermediate code performance

### 🔹 Target Code Generation

* Generating assembly-level or pseudo machine code
* Instruction selection and register allocation
* Low-level mapping of intermediate code

## ✅ How to Run

1. Ensure LEX, YACC, and a C compiler (e.g., GCC) are installed
2. Compile LEX and YACC files using the following steps:

   ```bash
   lex filename.l
   yacc -d filename.y
   gcc lex.yy.c y.tab.c -o output
   ./output
   ```
